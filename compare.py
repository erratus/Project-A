import os
import json
import time
from langchain_huggingface import HuggingFaceEmbeddings
from langchain_community.vectorstores import Chroma
from langchain_community.chat_models import ChatOllama
from langchain_core.messages import SystemMessage, HumanMessage

# === Paths and Config ===
jd_db_path = "chroma_db_jd"
resume_db_path = "chroma_db_resume"
model_name = "bigllama/mistralv01-7b:latest"

system_prompt = """You are a world-class HR, Talent Acquisition, and Generative AI Specialist with deep expertise in job-role alignment, semantic document comparison, and hiring decision automation.
You are tasked with comparing a candidate resume and a job description. Both are pre-parsed into structured fields: Skills, Education, Job Role, Experience, and Other Information. Your job is to assess the alignment **strictly based on meaning** — not exact keyword matches.
You must return a single valid JSON object in the structure described below.

### Instructions:

- Evaluate **semantic relevance**, not just keyword overlap. For example, treat "ML Engineer" and "Machine Learning Engineer" as identical.
- Use **real-world hiring logic**: If a resume **exceeds** the JD requirements (e.g., more skills, more education, deeper experience), the match_pct should be high — even **100%**.
- Avoid over-penalizing minor differences. Focus on **capability and fit**.
- NEVER hallucinate or infer information not explicitly present in either document.
- NEVER nest objects inside any field — your output must remain a **flat JSON**.
- Explanations must be **insightful, human-readable, and professional** — written as if speaking to a hiring manager.
- Escape any invalid characters like tabs/newlines using \\t and \\n.
- Do **not** include any commentary or text outside the JSON.

### Field Matching Logic:

1. **Skills**
   - Match based on technical equivalence.
   - If the resume includes **all** required skills or **more**, assign **100%**.
   - If semantically similar (e.g., "pandas" vs. "data manipulation in Python"), still assign high match_pct (80–95%).

2. **Education**
   - If the candidate's education level is **equal or higher** than the JD, score high.
   - Degrees in relevant fields or from reputable institutions should be favored.

3. **Experience**
   - Match on role relevance, technologies used, domain familiarity, and years of experience.
   - Experience that directly meets or exceeds JD expectations should score high (90–100%).

4. **Job Role**
   - Normalize semantically equivalent titles (e.g., "ML Engineer" = "Machine Learning Engineer").
   - If the resume job role **exactly matches** or semantically aligns with **any title** in the job description (e.g., "Generative AI Engineer" in both), assign **100%**.
   - If the resume title is a **parent or superset role** of the JD (e.g., "Data Scientist" when JD asks for "ML Engineer"), assign a **high match percentage (90–95%)**.
   - If the resume title is a **subset** (e.g., "ML Engineer" when JD includes "Generative AI Engineer"), still assign **high score (90–95%)**, if contextually relevant.
   - Recognize hierarchical and domain relationships:
     - Example: "Data Scientist" includes "ML Engineer" and "Generative AI Engineer" as subdomains.
     - "Machine Learning Engineer" is semantically equal to "ML Engineer".
   - Penalize only when there is a **significant deviation** in domain, seniority, or function (e.g., "Project Manager" vs. "ML Engineer").
   - Prioritize domain alignment, relevance to AI/ML/Generative AI, and explain clearly why a role is penalized or rewarded.


5. **OverallMatchPercentage**
   - Must be a weighted score calculated **heavily** from Skills, Experience, Education, and Job Role.
   - **Other Information** may provide a minor bonus/penalty (±5%).

6. **AI_Generated_Estimate_Percentage**
   - Estimate how likely the resume was generated by AI, based on repetition, unnatural tone, excessive perfection, or generic phrasing.

### Output Format (strict):

{
  "{resume_filename}": {
    "Skills": {
      "match_pct": float,
      "resume_value": string,
      "job_description_value": string,
      "explanation": string
    },
    "Education": {
      "match_pct": float,
      "resume_value": string,
      "job_description_value": string,
      "explanation": string
    },
    "Job Role": {
      "match_pct": float,
      "resume_value": string,
      "job_description_value": string,
      "explanation": string
    },
    "Experience": {
      "match_pct": float,
      "resume_value": string,
      "job_description_value": string,
      "explanation": string
    },
    "OverallMatchPercentage": float,
    "why_overall_match_is_this": string,
    "AI_Generated_Estimate_Percentage": float
  }
}

Return ONLY the JSON object. No extra comments or explanation."""
user_prompt_template = """Compare the following resume and job description using their parsed field data.

Each field below is populated from the database. Compare them **semantically and intelligently** using the structure below.

Use the following strict JSON format:

{{
  "{resume_filename}": {{
    "Skills": {{
      "match_pct": float,
      "resume_value": string,
      "job_description_value": string,
      "explanation": string
    }},
    "Education": {{
      "match_pct": float,
      "resume_value": string,
      "job_description_value": string,
      "explanation": string
    }},
    "Job Role": {{
      "match_pct": float,
      "resume_value": string,
      "job_description_value": string,
      "explanation": string
    }},
    "Experience": {{
      "match_pct": float,
      "resume_value": string,
      "job_description_value": string,
      "explanation": string
    }},
    "OverallMatchPercentage": float,
    "why_overall_match_is_this": string,
    "AI_Generated_Estimate_Percentage": float
  }}
}}

Return only the JSON object, and ensure:
- match_pct values reflect real semantic similarity (not keyword count).
- Explanations are professional, specific, and insightful.
- No nested JSON objects inside any value fields.
- No semicolons (;) in values — use periods or commas.
- No hallucinated info or missing keys."""

# === Embedding & DB Setup ===
embedding = HuggingFaceEmbeddings(model_name="sentence-transformers/all-MiniLM-L6-v2")
jd_store = Chroma(persist_directory=jd_db_path, embedding_function=embedding)
resume_store = Chroma(persist_directory=resume_db_path, embedding_function=embedding)

# === Load Parsed JD and Resume Docs ===
jd_docs = jd_store.similarity_search(".", k=100)
resume_docs = resume_store.similarity_search(".", k=100)

def safe_parse_json(doc_list, source_name):
    parsed = []
    for doc in doc_list:
        content = doc.page_content.strip()
        if not content:
            print(f"[WARN] Empty content in {source_name} doc: {doc.metadata.get('source', 'unknown')}")
            continue
        try:
            parsed.append(json.loads(content))
        except json.JSONDecodeError:
            print(f"[WARN] Skipping invalid JSON in {source_name} doc: {doc.metadata.get('source', 'unknown')}")
    return parsed

jd_jsons = safe_parse_json(jd_docs, "JD")
resume_jsons = safe_parse_json(resume_docs, "Resume")


jd = jd_jsons[0]  # assume only 1 JD

chat = ChatOllama(model=model_name, temperature=0.0, seed=42)

# === Matching Function ===
def run_match(resume, resume_filename):
    resume_str = json.dumps(resume, indent=2)
    jd_str = json.dumps(jd, indent=2)
    
    user_prompt = user_prompt_template.format(
        resume_filename=resume_filename
    ) + f"\n\nResume: {resume_str}\n\nJD: {jd_str}"

    messages = [
        SystemMessage(content=system_prompt),
        HumanMessage(content=user_prompt)
    ]

    try:
        response = chat.invoke(messages)
        content = response.content.strip()
        result = json.loads(content)
        return result
    except Exception as e:
        return {resume_filename: {"error": str(e)}}

# === Run and Collect ===
results = {}
for resume in resume_jsons:
    fname = resume.get("filename", f"resume_{int(time.time())}.json")
    match = run_match(resume, fname)
    results.update(match)

# === Save to File ===
os.makedirs("output", exist_ok=True)
with open("output/resume_jd_matches.json", "w") as f:
    json.dump(results, f, indent=2)

print("Matching complete. Results saved to output/resume_jd_matches.json")
